# BEGIN COPYRIGHT BLOCK
# This Program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; version 2 of the License.
# 
# This Program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License along with
# this Program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA 02111-1307 USA.
# 
# In addition, as a special exception, Red Hat, Inc. gives You the additional
# right to link the code of this Program with code not covered under the GNU
# General Public License ("Non-GPL Code") and to distribute linked combinations
# including the two, subject to the limitations in this paragraph. Non-GPL Code
# permitted under this exception must only link to the code of this Program
# through those well defined interfaces identified in the file named EXCEPTION
# found in the source code files (the "Approved Interfaces"). The files of
# Non-GPL Code may instantiate templates or use macros or inline functions from
# the Approved Interfaces without causing the resulting work to be covered by
# the GNU General Public License. Only Red Hat, Inc. may make changes or
# additions to the list of Approved Interfaces. You must obey the GNU General
# Public License in all respects for all of the Program code and other code used
# in conjunction with the Program except the Non-GPL Code covered by this
# exception. If you modify this file, you may extend this exception to your
# version of the file, but you are not obligated to do so. If you do not wish to
# provide this exception without modification, you must delete this exception
# statement from your version and license this file solely under the GPL without
# exception. 
# 
# 
# Copyright (C) 2007 Red Hat, Inc.
# All rights reserved.
# END COPYRIGHT BLOCK
#

###########################
#
# This perl module provides a way to set up a new installation after
# the binaries have already been extracted.  This is typically after
# using native packaging support to install the package e.g. RPM,
# pkgadd, depot, etc.  This script will show the license, readme,
# dsktune, then run the usual setup pre and post installers.
#
##########################

package DSMigration;
use Migration;
use Util;
use Inf;

# tempfiles
use File::Temp qw(tempfile tempdir);

# load perldap
use Mozilla::LDAP::Conn;
use Mozilla::LDAP::Utils qw(normalizeDN);
use Mozilla::LDAP::API qw(ldap_explode_dn);
use Mozilla::LDAP::LDIF;

use Exporter;
@ISA       = qw(Exporter);
@EXPORT    = qw(migrateDS);
@EXPORT_OK = qw(migrateDS);

use strict;

use SetupLog;
use Util;

# these are the attributes for which we will always use
# the new value, or which do not apply anymore
my %ignoreOld =
(
 'nsslapd-errorlog'                => 'nsslapd-errorlog',
 'nsslapd-accesslog'               => 'nsslapd-accesslog',
 'nsslapd-auditlog'                => 'nsslapd-auditlog',
 'nskeyfile'                       => 'nsKeyfile',
 'nscertfile'                      => 'nsCertfile',
 'nsslapd-pluginpath'              => 'nsslapd-pluginPath',
 'nsslapd-plugintype'              => 'nsslapd-pluginType',
 'nsslapd-pluginversion'           => 'nsslapd-pluginVersion',
 'nsslapd-plugin-depends-on-named' => 'nsslapd-plugin-depends-on-named',
# these are new attrs that we should just pass through
 'nsslapd-schemadir'               => 'nsslapd-schemadir',
 'nsslapd-lockdir'                 => 'nsslapd-lockdir',
 'nsslapd-tmpdir'                  => 'nsslapd-tmpdir',
 'nsslapd-certdir'                 => 'nsslapd-certdir',
 'nsslapd-ldapifilepath'           => 'nsslapd-ldapifilepath',
 'nsslapd-ldapilisten'             => 'nsslapd-ldapilisten',
 'nsslapd-ldapiautobind'           => 'nsslapd-ldapiautobind',
 'nsslapd-ldapimaprootdn'          => 'nsslapd-ldapimaprootdn',
 'nsslapd-ldapimaptoentries'       => 'nsslapd-ldapimaptoentries',
 'nsslapd-ldapiuidnumbertype'      => 'nsslapd-ldapiuidnumbertype',
 'nsslapd-ldapigidnumbertype'      => 'nsslapd-ldapigidnumbertype',
 'nsslapd-ldapientrysearchbase'    => 'nsslapd-ldapientrysearchbase',
 'nsslapd-ldapiautodnsuffix'       => 'nsslapd-ldapiautodnsuffix'
);

# these are the attributes for which we will always use
# the old value
my %alwaysUseOld =
(
 'aci'      => 'aci'
);

my $pkgname; # global used in several different places - set in migrateDS
my $oldsroot; # global used in several different places - set in migrateDS

sub getNewDbDir {
    my ($ent, $attr, $inst) = @_;
    my %objclasses = map { lc($_) => $_ } $ent->getValues('objectclass');
    my $cn = $ent->getValues('cn');
    my $newval;
    if ($objclasses{nsbackendinstance}) {
        $newval = "@localstatedir@/lib/$pkgname/$inst/db/$cn";
    } elsif (lc $cn eq 'config') {
        $newval = "@localstatedir@/lib/$pkgname/$inst/db";
    } elsif (lc $cn eq 'changelog5') {
        $newval = "@localstatedir@/lib/$pkgname/$inst/cldb";
    }
    debug(2, "New value [$newval] for attr $attr in entry ", $ent->getDN(), "\n");
    return $newval;
}

sub migrateCredentials {
    my ($ent, $attr, $inst) = @_;
    my $oldval = $ent->getValues($attr);
    debug(3, "Executing migratecred -o $oldsroot/$inst -n @instconfigdir@/$inst -c $oldval . . .\n");
    my $newval = `migratecred -o $oldsroot/$inst -n @instconfigdir@/$inst -c $oldval`;
    debug(3, "Converted old value [$oldval] to new value [$newval] for attr $attr in entry ", $ent->getDN(), "\n");
    return $newval;
}

# these are attributes that we have to transform from
# the old value to the new value (e.g. a pathname)
# The key of this hash is the attribute name.  The value
# is an anonymous sub which takes two arguments - the entry
# and the old value.  The return value of the sub is
# the new value
my %transformAttr =
(
 'nsslapd-directory' => \&getNewDbDir,
 'nsslapd-db-logdirectory' => \&getNewDbDir,
 'nsslapd-changelogdir' => \&getNewDbDir,
 'nsds5replicacredentials' => \&migrateCredentials,
 'nsmultiplexorcredentials' => \&migrateCredentials
);

sub copyDatabaseDirs {
    my $srcdir = shift;
    my $destdir = shift;
    if (-d $srcdir && ! -d $destdir) {
        debug(1, "Copying database directory $srcdir to $destdir\n");
        system ("cp -p -r $srcdir $destdir") == 0 or
            die "Could not copy database directory $srcdir to $destdir: $?";
    } elsif (! -d $srcdir) {
        die "Error: database directory $srcdir does not exist";
    } else {
        debug(1, "The destination directory $destdir already exists, copying files/dirs individually\n");
        foreach my $file (glob("$srcdir/*")) {
            debug(3, "Copying $file to $destdir\n");
            if (-f $file) {
                system ("cp -p $file $destdir") == 0 or
                    die "Error: could not copy $file to $destdir: $!";
            } elsif (-d $file) {
                system ("cp -p -r $file $destdir") == 0 or
                    die "Error: could not copy $file to $destdir: $!";
            }
        }
    }
}

sub copyDatabases {
    my $oldroot = shift;
    my $inst = shift;
    my $newdbdir = shift;

    # global config and instance specific config are children of this entry
    my $basedbdn = normalizeDN("cn=ldbm database,cn=plugins,cn=config");
    # get the list of databases, their index and transaction log locations
    my $fname = "$oldroot/$inst/config/dse.ldif";
    open( DSELDIF, "$fname" ) || die "Can't open $fname: $!";
    my $in = new Mozilla::LDAP::LDIF(*DSELDIF);
    my $targetdn = normalizeDN("cn=config,cn=ldbm database,cn=plugins,cn=config");
    while (my $ent = readOneEntry $in) {
        next if (!$ent->getDN()); # just skip root dse
        # look for the one level children of $basedbdn
        my @rdns = ldap_explode_dn($ent->getDN(), 0);
        my $parentdn = normalizeDN(join(',', @rdns[1..$#rdns]));
        if ($parentdn eq $basedbdn) {
            my $cn = $ent->getValues('cn');
            my %objclasses = map { lc($_) => $_ } $ent->getValues('objectclass');
            if ($cn eq 'config') { # global config
                debug(1, "Found ldbm database plugin config entry ", $ent->getDN(), "\n");
                my $dir = $ent->getValues('nsslapd-directory');
                my $homedir = $ent->getValues('nsslapd-db-home-directory');
                my $logdir = $ent->getValues('nsslapd-db-logdirectory');
                debug(1, "old db dir = $dir homedir = $homedir logdir = $logdir\n");
                my $srcdir = $homedir || $dir || "$oldroot/$inst/db";
                copyDatabaseDirs($srcdir, $newdbdir);
                copyDatabaseDirs($logdir, $newdbdir) if ($logdir && $logdir ne $srcdir);
            } elsif ($objclasses{nsbackendinstance}) {
                debug(1, "Found ldbm database instance entry ", $ent->getDN(), "\n");
                my $dir = $ent->getValues('nsslapd-directory');
                # the default db instance directory is
                # $oldroot/$inst/$cn
                debug(1, "old instance $cn dbdir $dir\n");
                my $srcdir = $dir || "$oldroot/$inst/db/$cn";
                copyDatabaseDirs($srcdir, "$newdbdir/$cn");
            } # else just ignore for now
        }
    }
    close DSELDIF;
}

sub copyChangelogDB {
    my $oldroot = shift;
    my $inst = shift;
    my $newdbdir = shift;
    # changelog config entry
    my $cldn = normalizeDN("cn=changelog5, cn=config");
    my $fname = "$oldroot/$inst/config/dse.ldif";
    open( DSELDIF, "$fname" ) || die "Can't open $fname: $!";
    my $in = new Mozilla::LDAP::LDIF(*DSELDIF);
    while (my $ent = readOneEntry $in) {
        my $targetdn = normalizeDN($ent->getDN());
        if ($targetdn eq $cldn) {
            my $oldcldir = $ent->getValues('nsslapd-changelogdir');
            debug(1, "old cldb dir = $oldcldir\n");
            my $srcdir = $oldcldir || "$oldroot/$inst/cldb";
            copyDatabaseDirs($srcdir, $newdbdir);
            last;
        }
    }
    close DSELDIF;
}

sub fixAttrsInEntry {
    my ($ent, $inst) = @_;
    for my $attr (keys %{$ent}) {
        my $lcattr = lc $attr;
        if ($transformAttr{$lcattr}) {
            $ent->setValues($attr, &{$transformAttr{$lcattr}}($ent, $attr, $inst));
        }
    }
}

sub mergeEntries {
    my ($old, $new, $inst) = @_;
    my %inoldonly; # attrs in old entry but not new one
    my %innewonly; # attrs in new entry but not old one
    my @attrs; # attrs common to old and new
    # if the attribute exists in the old entry but not the new one
    # we should probably add it (checking for special cases first)
    # if the attribute exists in the new entry but not the old one
    # we might have to delete it from the new entry
    # first, get a list of all attributes
    foreach my $attr (keys %{$old}) {
        if (! $new->exists($attr)) {
            $inoldonly{$attr} = $attr;
        } else {
            push @attrs, $attr;
        }
    }
    foreach my $attr (keys %{$new}) {
        if (! $old->exists($attr)) {
            $innewonly{$attr} = $attr;
        }
    }
            
    # iterate through the attr lists
    my $cn = lc $new->getValues("cn");
    foreach my $attr (keys %inoldonly, keys %innewonly, @attrs) {
        my $lcattr = lc $attr;
        if ($ignoreOld{$lcattr}) {
            next; # use new value or just omit if attr is obsolete
        } elsif ($transformAttr{$lcattr}) {
            # only transform if the value is in the old entry
            if (!$innewonly{$attr}) {
                $new->setValues($attr, &{$transformAttr{$lcattr}}($old, $attr, $inst));
            }
        } elsif ($cn eq "internationalization plugin" and $lcattr eq "nsslapd-pluginarg0") {
            next; # use the new value of this path name
        } elsif ($cn eq "referential integrity postoperation" and $lcattr eq "nsslapd-pluginarg1") {
            next; # use the new value of this path name
        } elsif ($innewonly{$attr}) {
            $new->remove($attr); # in new but not old - just remove it
        } else {
            $new->setValues($attr, $old->getValues($attr)); # use old value
        }
    }
}

sub mergeDseLdif {
    my $oldroot = shift;
    my $inst = shift;
    my $ent;

    # first, read in old file
    my %olddse; # map of normalized DN to Entry
    my @olddns; # the DNs in their original order
    my $fname = "$oldroot/$inst/config/dse.ldif";
    open( OLDDSELDIF, $fname ) || die "Can't open $fname: $!";
    my $in = new Mozilla::LDAP::LDIF(*OLDDSELDIF);
    while ($ent = readOneEntry $in) {
        my $dn = normalizeDN($ent->getDN());
        push @olddns, $dn;
        $olddse{$dn} = $ent;
    }
    close OLDDSELDIF;

    # next, read in new file
    my %newdse; # map of normalized DN to Entry
    my @newdns; # the DNs in their original order that are not in olddns
    $fname = "@instconfigdir@/$inst/dse.ldif";
    open( NEWDSELDIF, $fname ) || die "Can't open $fname: $!";
    $in = new Mozilla::LDAP::LDIF(*NEWDSELDIF);
    while ($ent = readOneEntry $in) {
        my $dn = normalizeDN($ent->getDN());
        $newdse{$dn} = $ent;
        if (! exists $olddse{$dn}) {
            push @newdns, $dn;
        }
    }
    close NEWDSELDIF;

    # temp file for new, merged dse.ldif
    my ($dsefh, $tmpdse) = tempfile(SUFFIX => '.ldif');
    # now, compare entries
    # if the entry exists in the old tree but not the new, add it
    # if the entry exists in the new tree but not the old, delete it
    # otherwise, merge the entries
    # @olddns contains the dns in the old dse.ldif, including ones that
    # may also be in the new dse.ldif
    # @newdns contains dns that are only in the new dse.ldif
    for my $dn (@olddns, @newdns) {
        my $oldent = $olddse{$dn};
        my $newent = $newdse{$dn};
        my $outputent;
        if ($oldent && !$newent) {
            # may have to fix up some values in the old entry
            fixAttrsInEntry($oldent, $inst);
            # output $oldent
            $outputent = $oldent;
        } elsif (!$oldent && $newent) {
            next if ($dn =~ /o=deleteAfterMigration/i);
            # output $newent
            $outputent = $newent;
        } else { #merge
            # $newent will contain the merged entry
            mergeEntries($oldent, $newent, $inst);
            $outputent = $newent;
        }
        # special fix for rootDSE - perldap doesn't like "" for a dn
        if (! $outputent->getDN()) {
            my $ary = $outputent->getLDIFrecords();
            shift @$ary; # remove "dn"
            shift @$ary; # remove the empty dn value
            print $dsefh "dn:\n";
            print $dsefh (Mozilla::LDAP::LDIF::pack_LDIF (78, $ary), "\n");
        } else {
            Mozilla::LDAP::LDIF::put_LDIF($dsefh, 78, $outputent);
        }
    }
    close $dsefh;

    return $tmpdse;
}

sub migrateDS {
    my $mig = shift;
    $pkgname = $mig->{pkgname}; # set globals
    $oldsroot = $mig->{oldsroot}; # set globals

    # for each instance
    foreach my $inst (@{$mig->{instances}}) {
        if (-f "@instconfigdir@/$inst/dse.ldif") {
            $mig->msg($WARN, 'instance_already_exists', "@instconfigdir@/$inst/dse.ldif");
            next;
        }
        # set instance specific defaults
        my $newdbdir = "@localstatedir@/lib/$pkgname/$inst/db";
        my $newcertdir = "@instconfigdir@/$inst";
        my $newcldbdir = "@localstatedir@/lib/$pkgname/$inst/cldb";

        # extract the information needed for ds_newinst.pl
        my $configdir = "$oldsroot/$inst/config";
        my $inf = createInfFromConfig($configdir, $inst);
        debug(2, "Using inffile $inf->{filename} created from $configdir\n");

        # create the new instance
        my ($rc, $output) = createDSInstance($inf);
        unlink($inf->{filename});
        if ($rc) {
            $mig->msg($FATAL, 'error_creating_dsinstance', $rc, $output);
            return 0;
        } else {
            $mig->msg('created_dsinstance', $output);
        }

        # copy over the files/directories
        # copy the databases
        copyDatabases($oldsroot, $inst, $newdbdir);

        # copy the security related files
        $mig->migrateSecurityFiles($inst, $newcertdir);

        # copy the repl changelog database
        copyChangelogDB($oldsroot, $inst, $newcldbdir);

        # merge the old info into the new dse.ldif
        my $tmpdse = mergeDseLdif($oldsroot, $inst);

        # get user/group of new dse
        my ($dev, $ino, $mode, $uid, $gid, @rest) = stat "@instconfigdir@/$inst/dse.ldif";
        # save the original new dse.ldif
        system("cp -p @instconfigdir@/$inst/dse.ldif @instconfigdir@/$inst/dse.ldif.premigrate");
        # copy the new one
        system("cp $tmpdse @instconfigdir@/$inst/dse.ldif");
        # change owner/group
        chmod $mode, "@instconfigdir@/$inst/dse.ldif";
        chown $uid, $gid, "@instconfigdir@/$inst/dse.ldif";

        # remove the temp one
        unlink($tmpdse);
    }

    return 1;
}

#############################################################################
# Mandatory TRUE return value.
#
1;
