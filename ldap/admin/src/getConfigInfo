#!perl
#
# BEGIN COPYRIGHT BLOCK
# This Program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; version 2 of the License.
# 
# This Program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License along with
# this Program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA 02111-1307 USA.
# 
# In addition, as a special exception, Red Hat, Inc. gives You the additional
# right to link the code of this Program with code not covered under the GNU
# General Public License ("Non-GPL Code") and to distribute linked combinations
# including the two, subject to the limitations in this paragraph. Non-GPL Code
# permitted under this exception must only link to the code of this Program
# through those well defined interfaces identified in the file named EXCEPTION
# found in the source code files (the "Approved Interfaces"). The files of
# Non-GPL Code may instantiate templates or use macros or inline functions from
# the Approved Interfaces without causing the resulting work to be covered by
# the GNU General Public License. Only Red Hat, Inc. may make changes or
# additions to the list of Approved Interfaces. You must obey the GNU General
# Public License in all respects for all of the Program code and other code used
# in conjunction with the Program except the Non-GPL Code covered by this
# exception. If you modify this file, you may extend this exception to your
# version of the file, but you are not obligated to do so. If you do not wish to
# provide this exception without modification, you must delete this exception
# statement from your version and license this file solely under the GPL without
# exception. 
# 
# 
# Copyright (C) 2001 Sun Microsystems, Inc. Used by permission.
# Copyright (C) 2005 Red Hat, Inc.
# All rights reserved.
# END COPYRIGHT BLOCK
#

# Get some configuration information from an instance

BEGIN {
	$| = 1;
	# print CGI header
	print "Content-type: text/plain\n\n";

	$isNT = -d '\\';
	$PATHSEP = $isNT ? "\\" : "/";
	# get the server root directory
	$sroot = $ENV{'NETSITE_ROOT'};
	@INC = ( '.', '../../../admin/admin/bin' );
	grep { s@/@\\@g } @INC if $isNT;
}

sub sigDieHandler {
	print @_, "\n";
	print "NMC_STATUS: ", $!+0, "\n";
	exit $!;
}

$SIG{__DIE__} = 'sigDieHandler';

# process the CGI input
use Cgi;

$oldSlapdConf = $cgiVars{'oldServerRoot'} . $PATHSEP . 'slapd-' .
	$cgiVars{'oldServerName'} . $PATHSEP . 'config' . $PATHSEP .
	'slapd.conf';

$foundLocalUser = 0;

open(OLDSLAPDCONF, $oldSlapdConf) or
	die "Error: could not open old config file $oldSlapdConf: $!";
while ($line = <OLDSLAPDCONF>) {
	chop $line;
	foreach $key (keys %cgiVars) {
		$param = $cgiVars{$key};
		if ($line =~ /^$param\s+/i) {
			($value = $') =~ s/^[\"]//;
			# remove leading "
			$value =~ s/[\"]$//;
			# remove trailing "
			print $key, ':', $value, "\n";
			if (lc($param) eq 'localuser') {
				$foundLocalUser = 1;
			}
		}
	}
	if ($line =~ /^directory\s+/i) { $dbdir = $';}
	# the user may have given us a network mounted old home directory, but in the
	# old instance's config files, the root directory referred to is usually
	# a local directory.  For example, suppose there is an automounter map for
	# hosts which maps onto /h e.g. /h/oldhost would contain all directories
	# exported via NFS.  Similarly, for NT, you could do \\oldhost\c to look
	# at the C: drive on the old host.  Or the user may have network mounted
	# the old server root some other way.  Anyway, we need to determine what
	# the old server root was local to the original host because that is what
	# will be referred to it the old config files.  So, we look at the errorlog
	# directive in slapd.conf and use whatever comes before the slapd-oldname
	elsif ($line =~ /\werrorlog\s+(.*)slapd-$cgiVars{'oldServerName'}/i) {
		$realOldDir = $1;
	}
	elsif ($line =~ /^security\s+/i) {
		if (lc($') eq 'on') {
			$security = 1;
		}
	}
	elsif ($line =~ /^encryption-alias\s+/i) {
		$encryptionalias = $';
	}
}
close(OLDSLAPDCONF);

if (! $realOldDir) {
	$realOldDir = $cgiVars{'oldServerRoot'};
}

# if security is enabled, see if there is a cert and key db
if ($security && $encryptionalias) {
	$secDir = $cgiVars{'oldServerRoot'} . $PATHSEP . 'alias';
	opendir(SECDIR, $secDir) or
		die "Error: could not open alias dir $secDir : $!";
	foreach (readdir(SECDIR)) {
		if (! /[.][.]?/) {
			if (/^$encryptionalias/i) {
				print 'needSecPwd:true', "\n";
				last;
			}
		}
	}
	closedir(SECDIR);
}
	
# the dbdir is stored as a local dir, but we may need a network dir
($networkDbDir = $dbdir) =~ s/^$realOldDir/$cgiVars{'oldServerRoot'}/ig;

if (! $isNT && $cgiVars{'oldlocaluser'} && ! $foundLocalUser) {
	# get the local user by doing a stat of the db directory
	$olduid = (stat($networkDbDir))[4];
	# convert the numeric uid to string name
	setpwent;
	while (@ent = getpwent) {
		if ($ent[2] == $olduid) {
			print 'oldlocaluser:', $ent[0], "\n";
			last;
		}
	}
	endpwent;
}

if (! $isNT && $cgiVars{'newlocaluser'}) {
	open(SSUSERS, "$sroot${PATHSEP}shared${PATHSEP}config${PATHSEP}ssusers.conf") or
		die "Error: could not open $sroot${PATHSEP}shared${PATHSEP}config${PATHSEP}ssusers.conf: $!";
	while (<SSUSERS>) {
		chop;
		if (/^SuiteSpotUser\s+/i) {
			print 'newlocaluser:', $', "\n";
		}
	}
	close(SSUSERS);
}

print "NMC_STATUS: 0\n";
exit 0;
